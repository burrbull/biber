use parent qw(crate::Output::base);

use crate::Config;
use crate::Constants;
use crate::Utils;
use List::AllUtils qw( :all );
use Encode;
use IO::File;
use Log::Log4perl qw( :no_extra_logdie_message );
use XML::Writer;
use Unicode::Normalize;

/// Class for biblatexml output of tool mode
pub struct BibLaTeXML;

impl BibLaTeXML {
  /// Initialize a crate::Output::biblatexml object
  fn new(obj) {
    let $self;
    if (defined($obj) && ref($obj) == "HASH") {
      $self = bless $obj, $class;
    }
    else {
      $self = bless {}, $class;
    }

    return $self;
  }

  /// Set the output target file of a crate::Output::biblatexml object
  /// A convenience around set_output_target so we can keep track of the
  /// filename
  fn set_output_target_file(self, $toolfile, $init) {

    // biblatexml output is only in tool mode and so we are looking at a data source name in
    // $ARGV[0]
    let $exts = join('|', values %DS_EXTENSIONS);
    let $schemafile = crate::Config->getoption("dsn") =~ s/\.(?:$exts)$/.rng/r;

    $self->{output_target_file} = $toolfile;

    // Initialise any output object like an XML Writer
    if ($init) {
      let $bltxml = "http://biblatex-biber.sourceforge.net/biblatexml";
      $self->{xml_prefix} = $bltxml;

      let $of;
      if ($toolfile == '-') {
        open($of, '>&:encoding(UTF-8)', STDOUT);
      }
      else {
        $of = IO::File->new($toolfile, '>:encoding(UTF-8)');
      }
      $of->autoflush;             // Needed for running tests to string refs

      let $xml = XML::Writer->new(OUTPUT      => $of,
                                ENCODING    => "UTF-8",
                                DATA_MODE   => 1,
                                DATA_INDENT => crate::Config->getoption("output_indent"),
                                NAMESPACES  => 1,
                                PREFIX_MAP  => {$bltxml => "bltx"});
      $xml->xmlDecl();
      $xml->pi("xml-model", "href=\"$schemafile\" type=\"application/xml\" schematypens=\"http://relaxng.org/ns/structure/1.0\"");
      $xml->comment("Auto-generated by crate::Output::biblatexml");
      $xml->startTag([$self->{xml_prefix}, "entries"]);
      return $xml;
    }
    return;
  }

  /// Set the output for an entry
  fn set_output_entry(self, $be, $section, $dm) {
    let $bee = $be->get_field("entrytype");
    let $dmh = crate::config::get_dm_helpers();
    let $secnum = $section->number;
    let $key = $be->get_field("citekey");
    let $xml = $self->{output_target};
    let $xml_prefix = $self->{xml_prefix};
    let $xnamesep = crate::Config->getoption("xnamesep");

    $xml->startTag([$xml_prefix, "entry"], id => NFC($key), entrytype => NFC($bee));

    // Filter aliases which point to this key an insert them
    if (let @ids = sort grep {$section->get_citekey_alias($_) == $key} section.get_citekey_aliases()) {
      $xml->startTag([$xml_prefix, "ids"]);
      $xml->startTag([$xml_prefix, "list"]);
      for id in (@ids) {
        $xml->dataElement([$xml_prefix, "item"], NFC($id));
      }
      $xml->endTag();// list
      $xml->endTag();// ids
    }

    // If CROSSREF and XDATA have been resolved, don't output them
    // We can't use the usual skipout test for fields not to be output
    // as this only refers to .bbl output and not to biblatexml output since this
    // latter is not really a "processed" output, it is supposed to be something
    // which could be again used as input and so we don't want to resolve/skip
    // fields like DATE etc.
    // This only applies to the XDATA field as more granular XDATA will already
    // have/have not been resolved on the basis of this variable
    if !(crate::Config->getoption("output_resolve_xdata")) {
      if (let $xdata = $be->get_field("xdata")) {
        $xml->startTag([$xml_prefix, "xdata"]);
        $xml->startTag([$xml_prefix, "list"]);
        for xd in ($xdata->@*) {
          $xml->dataElement([$xml_prefix, "item"], NFC($xd));
        }
        $xml->endTag(); // list
        $xml->endTag(); // xdata
      }
    }
    if !(crate::Config->getoption("output_resolve_crossrefs")) {
      if (let $crossref = $be->get_field("crossref")) {
        $xml->dataElement([$xml_prefix, "crossref"], NFC($crossref));
      }
    }

    // Per-entry options
    let @entryoptions;
    for opt in (crate::Config->getblxentryoptions($secnum, $key)) {
      push @entryoptions, $opt . '=' . crate::Config->getblxoption($secnum, $opt, undef, $key);
    }
    if @entryoptions {
      $xml->dataElement([$xml_prefix, "options"], NFC(join(',', @entryoptions)));
    }

    // Output name fields
    for namefield in dm.get_fields_of_type(FieldType::List, &[DataType::Name], None) {

      // Name loop
      if (let $nf = $be->get_field($namefield)) {

        // XDATA is special
        if (!crate::Config->getoption("output_resolve_xdata") ||
          !$be->is_xdata_resolved($namefield)) {
          let xdata = nf.get_xdata();
          if !xdata.is_empty() {
            $xml->emptyTag([$xml_prefix, "names"], "xdata" => NFC(xdatarefout(xdata, true)));
            continue;
          }
        }

        let @attrs = ("type" => $namefield);

        // Did we have "and others" in the data?
        if nf.get_morenames() {
          push @attrs, (morenames => 1);
        }

        // Add per-namelist options
        for nlo in (keys $CONFIG_SCOPEOPT_BIBLATEX{NAMELIST}->%*) {
          if (defined($nf->${\"get_$nlo"})) {
            let $nlov = $nf->${\"get_$nlo"};

            if ($CONFIG_BIBLATEX_OPTIONS{NAMELIST}{$nlo}{OUTPUT}) {
              push @attrs, ($nlo => map_boolean($nlo, $nlov, "tostring"));
            }
          }
        }

        $xml->startTag([$xml_prefix, "names"], @attrs);

        for (let $i = 0; $i <= $nf->names->$#*; $i++) {
          let $n = $nf->names->[$i];

          // XDATA is special
          if (!crate::Config->getoption("output_resolve_xdata") ||
            !$be->is_xdata_resolved($namefield, $i+1)) {
            let xdata = n.get_xdata();
            if !xdata.is_empty() {
              $xml->emptyTag([$xml_prefix, "name"], "xdata" => NFC(xdatarefout(xdata, true)));
              continue;
            }
          }

          $n->name_to_biblatexml($self, $xml, $key, $namefield, n.get_index());
        }

        $xml->endTag(); // Names
      }
    }

    // Output list fields
    for listfield in (sort $dm->get_fields_of_fieldtype("list")->@*) {
      if $dm->field_is_datatype("name", $listfield) { // name is a special list
        continue;
      }

      // List loop
      if (let $lf = $be->get_field($listfield)) {

        // XDATA is special
        if (!crate::Config->getoption("output_resolve_xdata") ||
            !$be->is_xdata_resolved($listfield)) {
          if (let $val = xdatarefcheck(lf, true)) {
            $xml->emptyTag([$xml_prefix, $listfield], "xdata" => NFC($val));
            continue;
          }
        }

        let @attrs;
        // Did we have a "more" list?
        if (lc($lf->[-1]) == crate::Config->getoption("others_string") ) {
          push @attrs, (morelist => 1);
          pop $lf->@*;               // remove the last element in the array
        }

        $xml->startTag([$xml_prefix, $listfield], @attrs);
        $xml->startTag([$xml_prefix, "list"]);

        // List loop
        let $itemcount = 1;

        for (let $i = 0; $i <= $lf->$#*; $i++) {
          let $f = $lf->[$i];
          let @lattrs;

          // XDATA is special
          if (!crate::Config->getoption("output_resolve_xdata") ||
              !$be->is_xdata_resolved($listfield, $i+1)) {
            if (let $val = xdatarefcheck(f, true)) {
              $xml->emptyTag([$xml_prefix, "item"], "xdata" => NFC($val));
              continue;
            }
          }

          $xml->dataElement([$xml_prefix, "item"], NFC($f), @lattrs);
        }
        $xml->endTag();           // list
        $xml->endTag();           // listfield
      }
    }

    // Standard fields
    // NOTE: already sorted
    for field in dm.get_fields_of_type(FieldType::Field,
                                                    &[DataType::Entrykey,
                                                    DataType::Key,
                                                    DataType::Literal,
                                                    DataType::Code,
                                                    DataType::Integer,
                                                    DataType::Verbatim,
                                                    DataType::Uri]) {
      let $val = $be->get_field($field);

      // XDATA is special
      if (!crate::Config->getoption("output_resolve_xdata") ||
          !$be->is_xdata_resolved($field)) {

        if (let $xval = xdatarefcheck(val, true)) {
          $xml->emptyTag([$xml_prefix, $field], "xdata" => NFC($xval));
          continue;
        }
      }

      if (length($val) || // length() catches '0' values, which we want
        ($dm->field_is_nullok($field) &&
        $be->field_exists($field))) {
        if $dm->get_fieldformat($field) == "xsv" {
          continue;
        }
        if $field == "crossref" { // this is handled above
          continue;
        }
        let @attrs;

        $xml->dataElement([$xml_prefix, $field], NFC($val), @attrs);
      }
    }

    // xsv fields
    // NOTE: BUG? incorrect function
    for xsvf in ($dm->get_fields_of_type(FieldType::Field, "xsv")->@*) {
      if (let $f = $be->get_field($xsvf)) {
        if $xsvf == "ids" { // IDS is special
          continue;
        }
        if $xsvf == "xdata" { // XDATA is special
          continue;
        }

        // XDATA is special
        if (!crate::Config->getoption("output_resolve_xdata") ||
            !$be->is_xdata_resolved($xsvf)) {
          if (let $val = xdatarefcheck(f, true)) {
            $xml->emptyTag([$xml_prefix, $xsvf], "xdata" => NFC($val));
            continue;
          }
        }

        $xml->dataElement([$xml_prefix, $xsvf], NFC(join(',',$f->@*)));
      }
    }

    // Range fields
    // NOTE: already sorted
    for rfield in dm.get_fields_of_datatype(&[DataType::Range]) {
      if ( let $rf = $be->get_field($rfield) ) {

        // XDATA is special
        if (!crate::Config->getoption("output_resolve_xdata") ||
            !$be->is_xdata_resolved($rfield)) {
          if (let $val = xdatarefcheck(rf, true)) {
            $xml->emptyTag([$xml_prefix, $rfield], "xdata" => NFC($val));
            continue;
          }
        }

        // range fields are an array ref of two-element array refs [range_start, range_end]
        // range_end can be be empty for open-ended range or undef
        $xml->startTag([$xml_prefix, $rfield]);
        $xml->startTag([$xml_prefix, "list"]);

        for f in ($rf->@*) {
          $xml->startTag([$xml_prefix, "item"]);
          if (defined($f->[1])) {
            $xml->dataElement([$xml_prefix, "start"], NFC($f->[0]));
            $xml->dataElement([$xml_prefix, "end"], NFC($f->[1]));
          }
          else {
            $xml->characters(NFC($f->[0]));
          }
          $xml->endTag();// item
        }
        $xml->endTag();// list
        $xml->endTag();// range
      }
    }

    // Date fields
    let %dinfo;
    // NOTE: already sorted
    for datefield in dm.get_fields_of_datatype(&[DataType::Date]) {
      let @attrs;
      let @start;
      let @end;
      let $overridey;
      let $overridem;
      let $overrideem;
      let $overrided;

      let ($d) = $datefield =~ m/^(.*)date$/;
      if (let $sf = $be->get_field("${d}year") ) { // date exists if there is a year

        if $d {
          push @attrs, ("type", $d); // ignore for main date
        }

        $xml->startTag([$xml_prefix, "date"], @attrs);

        // Uncertain and approximate dates
        if ($be->get_field("${d}dateuncertain") &&
            $be->get_field("${d}dateapproximate")) {
          $sf .= '%';
        }
        else {
          // Uncertain dates
          if ($be->get_field("${d}dateuncertain")) {
            $sf .= '?';
          }

          // Approximate dates
          if ($be->get_field("${d}dateapproximate")) {
            $sf .= '~';
          }
        }

        // Unknown dates
        if ($be->get_field("${d}dateunknown")) {
          $sf = "unknown";
        }

        let %yeardivisions = ( "spring"  => 21,
                              "summer"  => 22,
                              "autumn"  => 23,
                              "winter"  => 24,
                              "springN" => 25,
                              "summerN" => 26,
                              "autumnN" => 27,
                              "winterN" => 28,
                              "springS" => 29,
                              "summerS" => 30,
                              "autumnS" => 31,
                              "WinterS" => 32,
                              "Q1"      => 33,
                              "Q2"      => 34,
                              "Q3"      => 35,
                              "Q4"      => 36,
                              "QD1"     => 37,
                              "QD2"     => 38,
                              "QD3"     => 39,
                              "S1"      => 40,
                              "S2"      => 41 );

        // Did the date fields come from interpreting an EDTF 5.2.2 unspecified date?
        // If so, do the reverse of crate::Utils::parse_date_unspecified()
        if (let $unspec = $be->get_field("${d}dateunspecified")) {

          // 1990/1999 -> 199X
          if ($unspec == "yearindecade") {
            let ($decade) = $be->get_field("${d}year") =~ m/^(\d+)\d$/;
            $overridey = "${decade}X";
            $be->del_field("${d}endyear");
          }
          // 1900/1999 -> 19XX
          else if ($unspec == "yearincentury") {
            let ($century) = $be->get_field("${d}year") =~ m/^(\d+)\d\d$/;
            $overridey = "${century}XX";
            $be->del_field("${d}endyear");
          }
          // 1999-01/1999-12 => 1999-XX
          else if ($unspec == "monthinyear") {
            $overridem = "XX";
            $be->del_field("${d}endyear");
            $be->del_field("${d}endmonth");
          }
          // 1999-01-01/1999-01-31 -> 1999-01-XX
          else if ($unspec == "dayinmonth") {
            $overrided = "XX";
            $be->del_field("${d}endyear");
            $be->del_field("${d}endmonth");
            $be->del_field("${d}endday");
          }
          // 1999-01-01/1999-12-31 -> 1999-XX-XX
          else if ($unspec == "dayinyear") {
            $overridem = "XX";
            $overrided = "XX";
            $be->del_field("${d}endyear");
            $be->del_field("${d}endmonth");
            $be->del_field("${d}endday");
          }
        }

        // Seasons derived from EDTF dates
        if (let $s = $be->get_field("${d}yeardivision")) {
          $overridem = $yeardivisions{$s};
        }
        if (let $s = $be->get_field("${d}endyeardivision")) {
          $overrideem = $yeardivisions{$s};
        }
        $sf = $overridey || $sf;

        // strip undefs
        push @start,
          grep {$_}
            $sf,
              date_monthday($overridem || $be->get_field("${d}month")),
                date_monthday($overrided || $be->get_field("${d}day"));
        push @end,
          grep {defined($_)} // because end can be def but empty
            $be->get_field("${d}endyear"),
              date_monthday($overrideem || $be->get_field("${d}endmonth")),
                date_monthday($be->get_field("${d}endday"));
        // Date range
        if (@end) {
          let $start = NFC(join('-', @start));
          let $end = NFC(join('-', @end));

          // If start hour, there must be minute and second
          if (let $sh = $be->get_field("${d}hour")) {
            $start .= NFC('T' . sprintf('%.2d', $sh) . ':' .
              sprintf('%.2d', $be->get_field("${d}minute")) . ':' .
                sprintf('%.2d', $be->get_field("${d}second")));
          }

          // start timezone
          if (let $stz = $be->get_field("${d}timezone")) {
            $stz =~ s/\\bibtzminsep\s+/:/;
            $start .= NFC($stz);
          }

          // If end hour, there must be minute and second
          if (let $eh = $be->get_field("${d}endhour")) {
            $end .= NFC('T' . sprintf('%.2d', $eh) . ':' .
              sprintf('%.2d', $be->get_field("${d}endminute")) . ':' .
                sprintf('%.2d', $be->get_field("${d}endsecond")));
          }

          // end timezone
          if (let $etz = $be->get_field("${d}endtimezone")) {
            $etz =~ s/\\bibtzminsep\s+/:/;
            $end .= NFC($etz);
          }

          $xml->dataElement([$xml_prefix, "start"], $start);
          $xml->dataElement([$xml_prefix, "end"], $end);
        }
        else { // simple date
          $xml->characters(NFC(join('-', @start)));

          // If start hour, there must be minute and second
          if (let $sh = $be->get_field("${d}hour")) {
            $xml->characters(NFC('T' . sprintf('%.2d', $sh) . ':' .
                                sprintf('%.2d', $be->get_field("${d}minute")) . ':' .
                                sprintf('%.2d', $be->get_field("${d}second"))));
          }

          // start timezone
          if (let $stz = $be->get_field("${d}timezone")) {
            $stz =~ s/\\bibtzminsep\s+/:/;
            $xml->characters(NFC($stz));
          }
        }
        $xml->endTag();           // date
      }
    }

    // Annotations
    let ann = &crate::annotation::ANN.lock().unwrap();
    for f in (ann.get_annotated_fields(Scope::Field, key)) {
      for n in (ann.get_annotations(Scope::Field, key, f)) {
        let annot = ann.get_field_annotation(key, f, n).unwrap();
        let v = annot.value();
        let l = annot.is_literal();
        $xml->dataElement([$xml_prefix, "annotation"],
                          v,
                          field => f,
                          name  => n,
                          literal => l);
      }
    }

    for f in (ann.get_annotated_fields(Scope::Item, key)) {
      for n in (ann.get_annotations(Scope::Item, key, f)) {
        for (c, annot) in (ann.get_annotated_items(key, f, n)) {
          let v = annot.value();
          let l = annot.is_literal();
          $xml->dataElement([$xml_prefix, "annotation"],
                            v,
                            field => f,
                            name  => n,
                            item => c,
                            literal => l);
        }
      }
    }

    for f in (ann.get_annotated_fields(Scope::Part, key)) {
      for n in (ann.get_annotations(Scope::Part, key, f)) {
        for (c, p, annot) in (ann.get_annotated_parts(key, f, n)) {
          let v = annot.value();
          let l = annot.is_literal();
          $xml->dataElement([$xml_prefix, "annotation"],
                            v,
                            field => f,
                            name  => n,
                            item => c,
                            part => p,
                            literal => l);
        }
      }
    }

    $xml->endTag();

    return;
  }

  /// Tool output method
  fn output(self) {
    let $data = $self->{output_data};
    let $xml = $self->{output_target};
    let $target_string = "Target"; // Default
    let $dm = crate::config::get_dm();
    if ($self->{output_target_file}) {
      $target_string = $self->{output_target_file};
    }

      debug!("Preparing final output using class {}...", __PACKAGE__);
      debug!("Writing entries in tool mode");
    $xml->endTag();
    $xml->end();

    info!("Output to {}", target_string);
    let $exts = join('|', values %DS_EXTENSIONS);
    let $schemafile = crate::Config->getoption("dsn") =~ s/\.(?:$exts)$/.rng/r;

    // Generate schema to accompany output
    if !(crate::Config->getoption("no_bltxml_schema")) {
      $dm->generate_bltxml_schema($schemafile);
    }

    if (crate::Config->getoption("validate_bltxml")) {
      validate_biber_xml($target_string, "bltx", "http://biblatex-biber.sourceforge.net/biblatexml", $schemafile);
    }

    return;
  }

  /// Create the output from the sections data and push it into the
  /// output object.
  fn create_output_section(self) {
    let secnum = crate::MASTER.get_current_section();
    let section = crate::MASTER.sections().get_section(secnum);

    // We rely on the order of this array for the order of the .bbl
    for k in section.get_citekeys() {
      // Regular entry
      let be = section.bibentry(k) || biber_error("Cannot find entry with key '$k' to output");
      $self->set_output_entry(be, section, crate::config::get_dm());
    }

    // Make sure the output object knows about the output section
    $self->set_output_section($secnum, $section);

    return;
  }
}
